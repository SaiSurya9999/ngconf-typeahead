(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('ngconf-search', ['exports', '@angular/core'], factory) :
    (global = global || self, factory(global['ngconf-search'] = {}, global.ng.core));
}(this, (function (exports, i0) { 'use strict';

    var NgconfSearchService = /** @class */ (function () {
        function NgconfSearchService() {
        }
        return NgconfSearchService;
    }());
    NgconfSearchService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgconfSearchService_Factory() { return new NgconfSearchService(); }, token: NgconfSearchService, providedIn: "root" });
    NgconfSearchService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    NgconfSearchService.ctorParameters = function () { return []; };

    var NgconfSearchComponent = /** @class */ (function () {
        function NgconfSearchComponent() {
        }
        NgconfSearchComponent.prototype.ngOnInit = function () {
        };
        return NgconfSearchComponent;
    }());
    NgconfSearchComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'lib-ngconf-search',
                    template: "\n    <p>\n      ngconf-search works!\n    </p>\n  "
                },] }
    ];
    NgconfSearchComponent.ctorParameters = function () { return []; };

    var SearchFilterPipe = /** @class */ (function () {
        function SearchFilterPipe() {
        }
        SearchFilterPipe.prototype.transform = function (value, opt) {
            //If Array in ngFor is empty
            if (!value)
                return null;
            //If Search term is Empty
            if (!opt.term)
                return value;
            //For Better Results
            opt.term = opt.term.toString().toLowerCase();
            //let result = value.map(({ name }) => name);
            //let result = value.map(a => a.name);
            if (opt.prop) {
                if (opt.prop.toString() != "") {
                    var result = value.map(function (a) { return a[opt.prop.toString()]; });
                    //Filtered Results based on Search Term
                    return value.filter(function (item) {
                        // console.log(item);
                        return JSON.stringify(item[opt.prop.toString()]).toLowerCase().includes(opt.term.toString());
                    });
                }
            }
            else {
                //Filtered Results based on Search Term
                return value.filter(function (item) {
                    // console.log(item);
                    return JSON.stringify(item).toLowerCase().includes(opt.term.toString());
                });
            }
        };
        return SearchFilterPipe;
    }());
    SearchFilterPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'searchFilter',
                    pure: false
                },] }
    ];

    var NgconfSearchModule = /** @class */ (function () {
        function NgconfSearchModule() {
        }
        return NgconfSearchModule;
    }());
    NgconfSearchModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [NgconfSearchComponent, SearchFilterPipe],
                    imports: [],
                    exports: [NgconfSearchComponent, SearchFilterPipe]
                },] }
    ];

    /*
     * Public API Surface of ngconf-search
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NgconfSearchComponent = NgconfSearchComponent;
    exports.NgconfSearchModule = NgconfSearchModule;
    exports.NgconfSearchService = NgconfSearchService;
    exports.SearchFilterPipe = SearchFilterPipe;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngconf-search.umd.js.map
